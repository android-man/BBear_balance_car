/*************************************HEAD FILES******************************/
#include"BSP.H"

/*****************************public values***********************************/
float radian_filted = 0, radian_filted2 = 0;			//the angle which is filted
int16_t buf[4] = {0, 0, 0, 0};							//the array to store the mpu6050 data
uint32_t distance = 0;							   		//the car's total run distance
int16_t acc_x, acc_y, acc_z;											//acceleration on the x,z axis
int16_t gyro_y = 0, gyro_x = 0;												//angular speed ont the y axis
float radian_pt = 0;									//radian_pt:the angle which is accumulated;
float radian_temp1 = 0, radian_temp2 = 0;				//radian_temp1 and radian_temp2:temporary of angle calculate
																					//radian_temp2:temporary of angle calculate
float radian = 0;													//the angle which is calculated by the acceleration
int16_t *p;																//a pointer point to the array which store the mpu6050 data
int16_t leftspeed = 0,rightspeed = 0;			//the car's left wheel and right wheel	
short res_l = 0,res_r = 0;
pid_s Angle_PID, Angle_PID2;													//struct to store the angle PID data
pid_s Speed_PID;													//struct to store the speed PID data

uint8_t flag_l = 1, flag_r = 1;
uint8_t heart_flag = 0;
uint8_t remote_flag = 0x00;
int balan_pwm_ang = 0,balan_pwm_ang2 = 0,balan_pwm_spd = 0,balan_pwm = 0;
int balan_pwm_spd_l,balan_pwm_spd_r;

unsigned char control_data = 0x00;
int32_t run_l = 0x00,run_r = 0x00;

char first_time_flag = 1;									//for the first time to calculate the angle of the car use the acc_x

int8_t target_dir = 0; //0:no target dir 1:forward -1:back 3:left 4:right
/******************************************************************************
Name£ºRCC_Configration 
Function:	
		  	initialize the system clock
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
void RCC_Configuration()
{
	ErrorStatus HSEStartUpStatus;
	RCC_DeInit();
	RCC_HSEConfig(RCC_HSE_ON);
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
	if(HSEStartUpStatus == SUCCESS){
	    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); 
    	FLASH_SetLatency(FLASH_Latency_2);                    

    	RCC_HCLKConfig(RCC_SYSCLK_Div1);  
    	RCC_PCLK2Config(RCC_HCLK_Div1);		   
			RCC_PCLK1Config(RCC_HCLK_Div2);	 	  
    	RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);	
    	RCC_PLLCmd(ENABLE); 
    	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)	  
       	{
       	}
			RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
			while(RCC_GetSYSCLKSource() != 0x08)	  
       	{ 
       	}
	}
}

/******************************************************************************
Name£ºGPIO_Configuration 
Function:	
		  	initialize the GPIO
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
void GPIO_Configuration()
{
/************************************I2C GPIO*********************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | \
	RCC_APB2Periph_GPIOC /*| RCC_APB2Periph_AFIO*/, ENABLE);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;						//SCL
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;						//SDA
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_Init(GPIOB, &GPIO_InitStructure);	  

/***********************************PWM GPIO**********************************/
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;		 				//pwm-left-forward
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;		 				//pwm-left-back
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;		 				//pwm-right-forward
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;		 				//pwm-right-back
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  	GPIO_Init(GPIOB, &GPIO_InitStructure);
/***********************************SPEED*************************************/
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;					 		//left speed
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	

	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11;							//right speed
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12;							//speed
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_13;							//speed
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

/*************************************HEART LED*******************************/

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;  
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; 
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 
	GPIO_Init(GPIOB, &GPIO_InitStructure); 
	//GPIO_WriteBit(GPIOB,GPIO_Pin_8,Bit_RESET);

}

/******************************************************************************
Name£ºUSART_Configuration 
Function:	
		  	initialize the usart
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
void USART_Configuration()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_AFIO | \
	RCC_APB2Periph_USART1, ENABLE);
	
	GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_9;		//TX
	GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin  	= GPIO_Pin_10;		//RX	
	GPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;		                            
  GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_IN_FLOATING;                           
  GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	USART_InitStructure.USART_BaudRate   = 115200;	                                
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;	                    
	USART_InitStructure.USART_StopBits   = USART_StopBits_1;		                
	USART_InitStructure.USART_Parity     = USART_Parity_No;				            
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	                

	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);	
  USART_Init(USART1, &USART_InitStructure);
	USART_Cmd(USART1, ENABLE);	                                                    
}

/******************************************************************************
Name£ºNVIC_Configuration 
Function:	
		  	configuration the NVIC
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
void NVIC_Configuration(void)
{
   NVIC_InitTypeDef NVIC_InitStructure;
  
   /* Set the Vector Table base location at 0x08000000 */
   //NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
  
   /* Configure the NVIC Preemption Priority Bits */  
   NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);  
//   /* Enable the USART1 Interrupt */
//   NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;       
//   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
//   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//used to be 0	   
//   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;		   
//   NVIC_Init(&NVIC_InitStructure); 						   
  
	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
	NVIC_Init(&NVIC_InitStructure); 

  NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
 
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//3        
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	        
  NVIC_Init(&NVIC_InitStructure);
}

/******************************************************************************
Name£ºEXTI_Configuration 
Function:	
		  	PA6,PA7 interrupt configuration
Parameters£º
		   	void
Returns£º
			void 
Description:
			the interrupt configuration of PA6,PA7
******************************************************************************/
void EXTI_Configuration(void)
{
  EXTI_InitTypeDef EXTI_InitStructure;
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); 

  EXTI_DeInit();

  EXTI_ClearITPendingBit(EXTI_Line10);    	
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  EXTI_InitStructure.EXTI_Line = EXTI_Line10;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource10);

  
  EXTI_ClearITPendingBit(EXTI_Line11); 
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  EXTI_InitStructure.EXTI_Line = EXTI_Line11;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource11);
#if 1
  EXTI_ClearITPendingBit(EXTI_Line12); 
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  EXTI_InitStructure.EXTI_Line = EXTI_Line12;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource12);

  EXTI_ClearITPendingBit(EXTI_Line13);		
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  EXTI_InitStructure.EXTI_Line = EXTI_Line13;
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource13);
#endif
}

/******************************************************************************
Name£ºEXTI15_10_IRQHandler 
Function:	
		  	PB10,PB11 interrupt function
Parameters£º
		   	void
Returns£º
			void 
Description:
			the interrupt function of PB10,PB11
******************************************************************************/
#define WAIT_TIME 35
void EXTI15_10_IRQHandler(void)
{  
int i;
uint16_t GPIOx_val = 0x0000;
uint8_t gpiob10,gpiob12,gpiob11,gpiob13;
#if 0
	if(EXTI_GetITStatus(EXTI_Line10) != RESET){
		if(leftspeed == 1)
			leftspeed++;
		if(leftspeed == 2)
			leftspeed--;
		EXTI_ClearITPendingBit(EXTI_Line10);
	}
	if(EXTI_GetITStatus(EXTI_Line12) != RESET){
		if(leftspeed == 1)
			leftspeed++;
		if(leftspeed == 2)
			leftspeed--;
		EXTI_ClearITPendingBit(EXTI_Line12);
	}
	
	if(EXTI_GetITStatus(EXTI_Line11) != RESET){
		if(speed_dir_r == 1)
			rightspeed++;
		if(speed_dir_r == 2)
			rightspeed--;
		EXTI_ClearITPendingBit(EXTI_Line11);
	}
	if(EXTI_GetITStatus(EXTI_Line13) != RESET){
		if(speed_dir_r == 1)
			rightspeed++;
		if(speed_dir_r == 2)
			rightspeed--;
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
#else
	if(EXTI_GetITStatus(EXTI_Line10) != RESET){
		for(i = 0;i < WAIT_TIME; i++);
		GPIOx_val = GPIOB->IDR;//printf("%x\r\n",GPIOx_val);
		gpiob10 = (GPIOx_val & 0x0400)>>10;
		gpiob12 = (GPIOx_val & 0x1000)>>12;
		//printf("%x %x\r\n",gpiob10,gpiob12);
		if(gpiob10 == 0){
			if(gpiob12 == 0){
				speed_dir_l = 1;//FORWARD
				leftspeed++;//printf("00+\r\n");
			}else{
				speed_dir_l = 2;//BACK
				leftspeed--;//printf("01-\r\n");
			}
		}else{
			 if(gpiob12 == 1){
				speed_dir_l = 1;//FORWARD
				leftspeed++;//printf("11+\r\n");
			}else{
				speed_dir_l = 2;//BACK
				leftspeed--;//printf("10-\r\n");
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line10);	
	}
	if(EXTI_GetITStatus(EXTI_Line12) != RESET){
		for(i = 0;i < WAIT_TIME; i++);
		GPIOx_val = GPIOB->IDR;//printf("%x\r\n",GPIOx_val);
		gpiob10 = (GPIOx_val & 0x0400)>>10;
		gpiob12 = (GPIOx_val & 0x1000)>>12;
		//printf("%x %x\r\n",gpiob10,gpiob12);
		if(gpiob12 == 0){
			if(gpiob10 == 1){
				speed_dir_l = 1;//FORWARD
				leftspeed++;//printf("10+\r\n");
			}else{
				speed_dir_l = 2;//BACK
				leftspeed--;//printf("00-\r\n");
			}
		}else{
			if(gpiob10 == 0){
				speed_dir_l = 1;//FORWARD
				leftspeed++;//printf("01+\r\n");
			}else{
				speed_dir_l = 2;//BACK
				leftspeed--;//printf("11-\r\n");
			}
		}		
		EXTI_ClearITPendingBit(EXTI_Line12);	
	}

	if(EXTI_GetITStatus(EXTI_Line11) != RESET){
		for(i = 0;i < WAIT_TIME; i++);
		GPIOx_val = GPIOB->IDR;
		gpiob11 = (GPIOx_val & 0x0800)>>11;
		gpiob13 = (GPIOx_val & 0x2000)>>13;
		if(gpiob11 == 0){
			if(gpiob13 == 0){
				speed_dir_r = 1;//FORWARD
				rightspeed++;//printf("1 0 3 0 R++\r\n");
			}else{
				speed_dir_r = 2;//BACK
				rightspeed--;//printf("1 0 3 1 L--\r\n");
			}
		}else{
			if(gpiob13 == 1){
				speed_dir_r = 1;//FORWARD
				rightspeed++;//printf("1 1 3 1 R++\r\n");
			}else{
				speed_dir_r = 2;//BACK
				rightspeed--;//printf("1 1 3 0 R--\r\n");
			}
		}		
		EXTI_ClearITPendingBit(EXTI_Line11);	
	}
	if(EXTI_GetITStatus(EXTI_Line13) != RESET){
		for(i = 0;i < WAIT_TIME; i++);
		GPIOx_val = GPIOB->IDR;
		gpiob11 = (GPIOx_val & 0x0800)>>11;
		gpiob13 = (GPIOx_val & 0x2000)>>13;
		if(gpiob13 == 0){
			if(gpiob11 == 1){
				speed_dir_r = 1;//FORWARD
				rightspeed++;//printf("1 1 3 0 R++\r\n");
			}else{
				speed_dir_r = 2;//BACK
				rightspeed--;//printf("1 0 3 0 R--\r\n");
			}
		}else{
			if(gpiob11 == 0){
				speed_dir_r = 1;//FORWARD
				rightspeed++;//printf("1 0 3 1 R++\r\n");
			}else{
				speed_dir_r = 2;//BACK
				rightspeed--;//printf("1 1 3 1 R--\r\n");
			}
		}
		EXTI_ClearITPendingBit(EXTI_Line13);	
	}
#endif
}

/******************************************************************************
Name£ºUSART1_IRQHandler 
Function:	
		  	USART1 interrupt function
Parameters£º
		   	void
Returns£º
			void 
Description:
			receive cmd from the bluetooth module
			PS:it's better to use a queue loop to deal with the received data
******************************************************************************/
void USART1_IRQHandler(void)            
{
  volatile unsigned char dat;
   
  if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET){     
    dat = USART_ReceiveData(USART1); 
	//control_data = dat;      
     //if(dat == 0x63) 
	 //{  			
	  //dat = 0;
	  //printf("hello\r\n");                         			  
	 //}                                          			   
  }
} 

/******************************************************************************
Name£ºTIM3_IRQHandler 
Function:	
		  	TIM3 interrupt function
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
void TIM3_IRQHandler(void)
{
	if(TIM_GetITStatus(TIM3, TIM_IT_Update) == SET){
		TIM_ClearITPendingBit(TIM3, TIM_FLAG_Update);
	
#if 1		
		p = buf;
		READ_MPU6050(p);
		acc_x = p[0];
		acc_y = p[1];
		gyro_y = p[2];
		gyro_x = p[3];
		//printf("x:%d ygyro:%d y:%d xgyro:%d\r\n",acc_x,acc_y,gyro_y, gyro_x);

		acc_x += acc_x_offset;
		acc_y += acc_y_offset;
		gyro_y += gyro_y_offset;
		gyro_x += gyro_x_offset;
		//printf("x:%d ygyro:%d y:%d xgyro:%d\r\n",acc_x,acc_y,gyro_y, gyro_x);
		//printf("%d\n",acc_y);

		radian = (float)((float)acc_x / 8192);
		radian = asin(radian);
		radian = (radian * 180.0) / 3.1415926;
		radian_temp1 = (((float)gyro_y) / 16.4) * 0.01;//0.01 mean cal the radian every 0.01s			
		//radian_pt += radian_temp1;
		radian_filted = Kaerman_Filter(radian_filted, -radian, radian_temp1);

		radian = (float)((float)acc_y / 8192);
		radian = asin(radian);
		radian = (radian * 180.0) / 3.1415926;
		radian_temp2 = (((float)gyro_x) / 16.4) * 0.01;//0.01 mean cal the radian every 0.01s
		//radian_pt2 += radian_temp2;
		radian_filted2 = Kaerman_Filter(radian_filted2, radian, radian_temp2);

		//printf("0x%x\r\n",control_data);
		if(control_data == 0x18)
			target_dir = 1;
		else if(control_data == 0x4a)
			target_dir = 2;
		else if(control_data == 0x10){
			//run_l = L_R;
			//run_r = -L_R;
			target_dir = 3;
		}
		else if(control_data == 0x5a){
			//run_l = -L_R;
			//run_r = L_R;
			target_dir = 4;
		}
		else{
			run_l = 0;
			run_r = 0;
			target_dir = 0;
		}
		control_data = 0x00;
		//get the speed of the car
		if(leftspeed >= 0)
			res_l = leftspeed>=3?3:leftspeed;
		else
			res_l = leftspeed<=-3?-3:leftspeed;

		if(rightspeed >= 0)
			res_r = rightspeed>=3?3:rightspeed;
		else
			res_r = rightspeed<=-3?-3:rightspeed;
		leftspeed = 0;
		rightspeed = 0;

		balan_pwm_ang = PID_Cal_Ang(&Angle_PID, -radian_filted, radian_temp1, 0);
		balan_pwm_ang2= PID_Cal_Ang(&Angle_PID2, radian_filted2, radian_temp2, 0);
		balan_pwm_spd_l  = PID_Cal_Speed(&Speed_PID,res_l,target_dir,LEFT_WHEEL);
		//balan_pwm_spd_r  = PID_Cal_Speed(&Speed_PID,res_r,target_dir,RIGHT_WHEEL);

		if(radian_filted > -45 && radian_filted < 45)
			//PWM_Control(balan_pwm_ang + balan_pwm_spd_l , balan_pwm_ang + balan_pwm_spd_r );
			PWM_Control(balan_pwm_ang2, 0/*balan_pwm_ang-balan_pwm_spd_l*/);
		else{
			PWM_Control(0, 0);
		}

//		printf("%x\n",speed_dir);
//		printf("%d ",balan_pwm);
//		printf("%d ",res_l); 
//		printf("%d %d\n",res_r, res_l);
//		printf(",%.1lf\n",radian_filted);
//		printf(",%.1lf\n",radian_filted2);
//		printf(" %d",balan_pwm_ang);
//		printf(" %d\n",balan_pwm_spd);
//		printf(",%.1lf\n",radian_filted);
//		printf("%.1lf,%.1lf,%.1lf\r\n",radian_filted,-radian,radian_pt);
#endif	
	}	
}

/******************************************************************************
Name£ºTIM2_IRQHandler 
Function:	
		  	TIM2 interrupt function to calculate the angle of the car
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
u8 	RmtSta=0;	  	  
u16 Dval;		//ÏÂ½µÑØÊ±¼ÆÊýÆ÷µÄÖµ
u32 RmtRec=0;	//ºìÍâ½ÓÊÕµ½µÄÊý¾Ý	   		    
u8  RmtCnt=0;	//°´¼ü°´ÏÂµÄ´ÎÊý
u8 t1,t2;
void TIM2_IRQHandler(void)
{
	if(TIM_GetITStatus(TIM2, TIM_IT_Update) == SET){
		
		if(RmtSta&0x80){										//ÉÏ´ÎÓÐÊý¾Ý±»½ÓÊÕµ½ÁË
			RmtSta&=~0X10;										//È¡ÏûÉÏÉýÑØÒÑ¾­±»²¶»ñ±ê¼Ç
			if((RmtSta&0X0F)==0X00)RmtSta|=1<<6;				//±ê¼ÇÒÑ¾­Íê³ÉÒ»´Î°´¼üµÄ¼üÖµÐÅÏ¢²É¼¯
			if((RmtSta&0X0F)<14)RmtSta++;
			else
			{
				RmtSta&=~(1<<7);								//Çå¿ÕÒýµ¼±êÊ¶
				RmtSta&=0XF0;									//Çå¿Õ¼ÆÊýÆ÷	
			}						 	   	
		}
		      
	if(RmtSta&(1<<6)){															//µÃµ½Ò»¸ö°´¼üµÄËùÓÐÐÅÏ¢ÁË	 
	    t1=RmtRec>>24;															//µÃµ½µØÖ·Âë
	    t2=(RmtRec>>16)&0xff;													//µÃµ½µØÖ··´Âë 
 	    if((t1==(u8)~t2)&&t1==REMOTE_ID){ 										//¼ìÑéÒ£¿ØÊ¶±ðÂë(ID)¼°µØÖ· 	    
	        t1=RmtRec>>8;
	        t2=RmtRec; 	
	        //if(t1==(u8)~t2)
			//	sta=t1;															//¼üÖµÕýÈ·	 
			control_data = t1;
		}   
		if((control_data==0)||((RmtSta&0X80)==0)){										//°´¼üÊý¾Ý´íÎó/Ò£¿ØÒÑ¾­Ã»ÓÐ°´ÏÂÁË		
		 	RmtSta&=~(1<<6);													//Çå³ý½ÓÊÕµ½ÓÐÐ§°´¼ü±êÊ¶
			RmtCnt=0;															//Çå³ý°´¼ü´ÎÊý¼ÆÊýÆ÷
		}
	}
	#if 0
	if(control_data){
			//printf("%x\r\n",control_data);
			heart_flag++;
			if(heart_flag % 2){
				GPIO_SetBits(GPIOB, GPIO_Pin_5);
				//GPIO_SetBits(GPIOC, GPIO_Pin_13);
				}
			else{
				GPIO_ResetBits(GPIOB, GPIO_Pin_5);
				//GPIO_ResetBits(GPIOC, GPIO_Pin_13);
				}

			if(heart_flag >= 2)
				heart_flag = 0;
			}
	#else
	if(control_data)
		GPIO_SetBits(GPIOB, GPIO_Pin_5);
	else
		GPIO_ResetBits(GPIOB, GPIO_Pin_5);
	#endif

		TIM_ClearITPendingBit(TIM2, TIM_FLAG_Update);
	} 
	 	
	if(TIM_GetITStatus(TIM2,TIM_IT_CC4)!=RESET){	  
		if(RDATA){															//ÉÏÉýÑØ²¶»ñ
			TIM_OC4PolarityConfig(TIM2,TIM_ICPolarity_Falling);				//CC1P=1 ÉèÖÃÎªÏÂ½µÑØ²¶»ñ				
	    	TIM_SetCounter(TIM2,0);	   										//Çå¿Õ¶¨Ê±Æ÷Öµ
			RmtSta|=0X10;													//±ê¼ÇÉÏÉýÑØÒÑ¾­±»²¶»ñ
		}else{																//ÏÂ½µÑØ²¶»ñ
  			 Dval=TIM_GetCapture4(TIM2);									//¶ÁÈ¡CCR1Ò²¿ÉÒÔÇåCC1IF±êÖ¾Î»
			 TIM_OC4PolarityConfig(TIM2,TIM_ICPolarity_Rising); 			//CC4P=0	ÉèÖÃÎªÉÏÉýÑØ²¶»ñ
 			
			if(RmtSta&0X10){												//Íê³ÉÒ»´Î¸ßµçÆ½²¶»ñ 
 				if(RmtSta&0X80){											//½ÓÊÕµ½ÁËÒýµ¼Âë									
					if(Dval>300&&Dval<800){									//560Îª±ê×¼Öµ,560us					
						RmtRec<<=1;											//×óÒÆÒ»Î».
						RmtRec|=0;											//½ÓÊÕµ½0	   
					}else if(Dval>1400&&Dval<1800){							//1680Îª±ê×¼Öµ,1680us					
						RmtRec<<=1;											//×óÒÆÒ»Î».
						RmtRec|=1;											//½ÓÊÕµ½1
					}else if(Dval>2200&&Dval<2600){							//µÃµ½°´¼ü¼üÖµÔö¼ÓµÄÐÅÏ¢ 2500Îª±ê×¼Öµ2.5ms					
						RmtCnt++; 											//°´¼ü´ÎÊýÔö¼Ó1´Î
						RmtSta&=0XF0;										//Çå¿Õ¼ÆÊ±Æ÷		
					}
 				}else if(Dval>4200&&Dval<4700){								//4500Îª±ê×¼Öµ4.5ms				
					RmtSta|=1<<7;											//±ê¼Ç³É¹¦½ÓÊÕµ½ÁËÒýµ¼Âë
					RmtCnt=0;												//Çå³ý°´¼ü´ÎÊý¼ÆÊýÆ÷
				}						 
			}
			RmtSta&=~(1<<4);
		}

		TIM_ClearFlag(TIM2,TIM_IT_Update|TIM_IT_CC4);				 		     	    					   
	}
}

/******************************************************************************
Name£ºRemote_Scan 
Function:	
		  	receive data from HX1383
Parameters£º
		   	void
Returns£º
			void 
Description:
			null
******************************************************************************/
uint8_t Remote_Scan(void)
{        
	u8 sta=0;       
    u8 t1,t2;  
	if(RmtSta&(1<<6)){															//µÃµ½Ò»¸ö°´¼üµÄËùÓÐÐÅÏ¢ÁË	 
	    t1=RmtRec>>24;															//µÃµ½µØÖ·Âë
	    t2=(RmtRec>>16)&0xff;													//µÃµ½µØÖ··´Âë 
 	    if((t1==(u8)~t2)&&t1==REMOTE_ID){ 										//¼ìÑéÒ£¿ØÊ¶±ðÂë(ID)¼°µØÖ· 	    
	        t1=RmtRec>>8;
	        t2=RmtRec; 	
	        if(t1==(u8)~t2)sta=t1;												//¼üÖµÕýÈ·	 
		}   
		if((sta==0)||((RmtSta&0X80)==0)){										//°´¼üÊý¾Ý´íÎó/Ò£¿ØÒÑ¾­Ã»ÓÐ°´ÏÂÁË		
		 	RmtSta&=~(1<<6);													//Çå³ý½ÓÊÕµ½ÓÐÐ§°´¼ü±êÊ¶
			RmtCnt=0;															//Çå³ý°´¼ü´ÎÊý¼ÆÊýÆ÷
		}
	}  
    return sta;
}
